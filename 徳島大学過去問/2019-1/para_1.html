<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>英文解釈ビジュアライザー - 徳島大学2019</title>
    
    <!-- スタイルシートの読み込み -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React本体の読み込み -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- JSX変換用（ブラウザでReactを動かすため） -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- フォント -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-serif { font-family: 'Times New Roman', Times, serif; }
        .font-sans { font-family: 'Inter', 'Noto Sans JP', sans-serif; }
        /* 読み込み中のスタイル */
        #loading { padding: 20px; text-align: center; color: #666; }
        #error-display { color: red; padding: 20px; display: none; border: 1px solid red; margin: 20px; background: #fff0f0; }
    </style>
</head>
<body class="bg-slate-50 text-slate-900">

    <!-- アプリケーションの描画場所 -->
    <div id="root">
        <div id="loading">
            読み込み中...<br>
            画面が切り替わらない場合は、インターネット接続を確認し、<br>
            ファイルを「UTF-8」で保存し直してください。
        </div>
    </div>
    <div id="error-display"></div>

    <!-- エラーハンドリング用スクリプト -->
    <script>
        window.onerror = function(message, source, lineno, colno, error) {
            const el = document.getElementById('error-display');
            el.style.display = 'block';
            el.innerHTML = '<strong>エラーが発生しました:</strong><br>' + message + '<br><small>' + source + ':' + lineno + '</small>';
            document.getElementById('loading').style.display = 'none';
        };
    </script>

    <!-- メインプログラム -->
    <script type="text/babel">
        // アイコンコンポーネント（SVG定義）
        const ChevronRight = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
        );
        const ChevronLeft = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
        );
        const RefreshCw = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
        );

        // データ定義
        const SENTENCE_1 = "Those who complain about the low level of skill in writing and reading that is now attained by most graduates of our schools and colleges make the mistake of assuming that if these deficiencies were remedied, all would be well.";
        const SENTENCE_2 = "They assume that, if someone has learned to write and read well, she will of course know how to speak and listen well.";
        const SENTENCE_3 = "That is simply not the case.";
        const SENTENCE_4 = "The reason why is that speaking and listening differ in remarkable ways from writing and reading.";
        const SENTENCE_5 = "This difference makes it much more difficult to acquire the required skills.";

        const RAW_SENTENCE = `${SENTENCE_1} ${SENTENCE_2} ${SENTENCE_3} ${SENTENCE_4} ${SENTENCE_5}`;
        const SOURCE_CREDIT = "出典元：徳島大学2019年大問１";

        const WORDS = RAW_SENTENCE.split(' ').map((word, index) => ({
            id: index,
            text: word
        }));

        const JP_CHUNKS = [
            { id: 0, text: "学校や大学の卒業生のほとんどが現在到達している" },
            { id: 1, text: "読み書きの能力レベルが" },
            { id: 2, text: "低いことについて" },
            { id: 3, text: "不満を言う" },
            { id: 4, text: "人々は、" },
            { id: 5, text: "もしこれらの欠陥が改善されれば、" },
            { id: 6, text: "すべてがうまくいくと" },
            { id: 7, text: "仮定するという" },
            { id: 8, text: "間違いを犯している。" },
            { id: 9, text: "彼らは、" },
            { id: 10, text: "もし誰かが読み書きをうまく学んだなら、" },
            { id: 11, text: "その人は" },
            { id: 12, text: "当然" },
            { id: 13, text: "話すことや聞くことも" },
            { id: 14, text: "うまくできる方法を知っているだろうと" },
            { id: 15, text: "仮定している。" },
            { id: 16, text: "それは" },
            { id: 17, text: "全くもって事実ではない。" },
            { id: 18, text: "その理由は、" },
            { id: 19, text: "話すことと聞くことは" },
            { id: 20, text: "読み書きとは" },
            { id: 21, text: "著しい点で" },
            { id: 22, text: "異なっている" },
            { id: 23, text: "からである。" },
            { id: 24, text: "この違いが" },
            { id: 25, text: "必要なスキルを習得することを" },
            { id: 26, text: "ずっと難しく" },
            { id: 27, text: "している。" }
        ];

        const range = (start, end) => Array.from({ length: end - start + 1 }, (_, i) => start + i);

        const COLORS = {
            S: '#ef4444', V: '#ef4444', O: '#ef4444', C: '#ef4444',
            REL: '#3b82f6', MOD: '#10b981', ETC: '#f97316', GRAY: '#64748b'
        };

        const STEPS = [
            {
                title: "第1文: 全体構造の把握",
                description: "まずは第1文全体を読みます。骨格は「人々(Those)は...間違いを犯している(make the mistake)」です。",
                annotations: [],
                highlightIds: range(0, 39),
                jpHighlightIds: range(0, 8),
                mainColor: COLORS.GRAY
            },
            {
                title: "主語(S)の発見",
                description: "文頭の 'Those' が主語(S)です。日本語では文の途中の「人々は」に相当します。",
                annotations: [ { type: 'symbol', targetId: 0, label: 'S', color: COLORS.S } ],
                highlightIds: [0],
                jpHighlightIds: [4],
                mainColor: COLORS.S
            },
            {
                title: "関係代名詞節の開始",
                description: "'who' は関係代名詞です。ここから長い形容詞節が始まり、先行詞 'Those' を修飾します。",
                annotations: [
                    { type: 'symbol', targetId: 0, label: 'S', color: COLORS.S },
                    { type: 'bracket-start', targetId: 1, color: COLORS.REL },
                    { type: 'arrow', fromId: 1, toId: 0, color: COLORS.REL }
                ],
                highlightIds: [1],
                jpHighlightIds: [0, 1, 2, 3],
                mainColor: COLORS.REL
            },
            {
                title: "節内部の構造",
                description: "節の中身です。'complain' が動詞、'about...' が不平の内容です。",
                annotations: [
                    { type: 'symbol', targetId: 0, label: 'S', color: COLORS.S },
                    { type: 'bracket-start', targetId: 1, color: COLORS.REL },
                    { type: 'arrow', fromId: 1, toId: 0, color: COLORS.REL },
                    { type: 'slash', targetId: 1, color: COLORS.GRAY },
                    { type: 'underline', startId: 2, endId: 13, label: 'about...', color: COLORS.GRAY }
                ],
                highlightIds: range(1, 13),
                jpHighlightIds: [0, 1, 2, 3],
                mainColor: COLORS.REL
            },
            {
                title: "二重の修飾構造",
                description: "'level of skill' を修飾する 'that' 節です。「現在～到達している」レベル、という意味です。",
                annotations: [
                    { type: 'symbol', targetId: 0, label: 'S', color: COLORS.S },
                    { type: 'bracket-start', targetId: 1, color: COLORS.REL },
                    { type: 'arrow', fromId: 1, toId: 0, color: COLORS.REL },
                    { type: 'bracket-sub', startId: 14, endId: 24, label: 'that節', color: COLORS.MOD },
                    { type: 'arrow', fromId: 14, toId: 6, color: COLORS.MOD }
                ],
                highlightIds: range(14, 24),
                jpHighlightIds: [0, 1],
                mainColor: COLORS.MOD
            },
            {
                title: "主節の動詞(V)の発見",
                description: "長い修飾語句が終わり、ようやく主節の動詞 'make' が現れました。",
                annotations: [
                    { type: 'symbol', targetId: 0, label: 'S', color: COLORS.S },
                    { type: 'bracket-full', startId: 1, endId: 24, label: '関係詞節', color: COLORS.REL },
                    { type: 'symbol', targetId: 25, label: 'V', color: COLORS.V }
                ],
                highlightIds: [25],
                jpHighlightIds: [8],
                mainColor: COLORS.V
            },
            {
                title: "目的語(O)の確定",
                description: "'the mistake' が目的語(O)です。「間違いを犯す」＝「間違ってしまう」となります。",
                annotations: [
                    { type: 'symbol', targetId: 0, label: 'S', color: COLORS.S },
                    { type: 'bracket-full', startId: 1, endId: 24, label: 'M', color: COLORS.GRAY }, 
                    { type: 'symbol', targetId: 25, label: 'V', color: COLORS.V },
                    { type: 'symbol', targetId: 27, label: 'O', color: COLORS.O },
                    { type: 'slash', targetId: 27, color: COLORS.GRAY }
                ],
                highlightIds: [26, 27],
                jpHighlightIds: [8],
                mainColor: COLORS.O
            },
            {
                title: "同格のof",
                description: "'of assuming...' は mistake の内容を説明する同格の表現です。「～と仮定するという間違い」",
                annotations: [
                    { type: 'symbol', targetId: 0, label: 'S', color: COLORS.S },
                    { type: 'symbol', targetId: 25, label: 'V', color: COLORS.V },
                    { type: 'symbol', targetId: 27, label: 'O', color: COLORS.O },
                    { type: 'arrow', fromId: 28, toId: 27, color: COLORS.ETC },
                    { type: 'underline', startId: 29, endId: 39, label: 'assuming...', color: COLORS.ETC }
                ],
                highlightIds: range(28, 39),
                jpHighlightIds: [5, 6, 7],
                mainColor: COLORS.ETC
            },
            {
                title: "第2文: 主語と動詞",
                description: "'They' は前の文の 'Those who complain...' を指します。",
                annotations: [
                    { type: 'symbol', targetId: 40, label: 'S', color: COLORS.S },
                    { type: 'symbol', targetId: 41, label: 'V', color: COLORS.V },
                    { type: 'bracket-start', targetId: 42, color: COLORS.REL },
                ],
                highlightIds: [40, 41],
                jpHighlightIds: [9, 15],
                mainColor: COLORS.S
            },
            {
                title: "挿入されたif節",
                description: "that節の中に、カンマで挟まれたif節「もし読み書きをうまく学んだなら」が挿入されています。",
                annotations: [
                    { type: 'symbol', targetId: 40, label: 'S', color: COLORS.S },
                    { type: 'symbol', targetId: 41, label: 'V', color: COLORS.V },
                    { type: 'bracket-sub', startId: 43, endId: 51, label: 'if節', color: COLORS.GRAY },
                ],
                highlightIds: range(43, 51),
                jpHighlightIds: [10],
                mainColor: COLORS.GRAY
            },
            {
                title: "that節の主部",
                description: "「彼女(その人)は、当然～を知っているだろう」",
                annotations: [
                    { type: 'symbol', targetId: 40, label: 'S', color: COLORS.S },
                    { type: 'symbol', targetId: 41, label: 'V', color: COLORS.V },
                    { type: 'bracket-start', targetId: 42, color: COLORS.REL },
                    { type: 'symbol', targetId: 52, label: "S'", color: COLORS.MOD },
                    { type: 'symbol', targetId: 56, label: "V'", color: COLORS.MOD },
                    { type: 'underline', startId: 54, endId: 55, label: 'M', color: COLORS.GRAY },
                ],
                highlightIds: [52, 53, 54, 55, 56],
                jpHighlightIds: [11, 12, 14],
                mainColor: COLORS.MOD
            },
            {
                title: "how to 不定詞",
                description: "'how to...' は「～する方法」という名詞句を作り、knowの目的語になっています。",
                annotations: [
                    { type: 'symbol', targetId: 52, label: "S'", color: COLORS.MOD },
                    { type: 'symbol', targetId: 56, label: "V'", color: COLORS.MOD },
                    { type: 'bracket-sub', startId: 57, endId: 62, label: "O'", color: COLORS.MOD },
                ],
                highlightIds: range(57, 62),
                jpHighlightIds: [13, 14],
                mainColor: COLORS.MOD
            },
            {
                title: "第3文: 否定の強調",
                description: "「それは全くもって事実ではない」。前の文の内容（仮定）を強く否定しています。",
                annotations: [
                    { type: 'symbol', targetId: 63, label: 'S', color: COLORS.S },
                    { type: 'symbol', targetId: 64, label: 'V', color: COLORS.V },
                    { type: 'underline', startId: 65, endId: 65, label: 'M', color: COLORS.GRAY },
                    { type: 'symbol', targetId: 68, label: 'C', color: COLORS.C },
                    { type: 'arrow', fromId: 63, toId: 68, color: COLORS.C }
                ],
                highlightIds: range(63, 68),
                jpHighlightIds: [16, 17],
                mainColor: COLORS.S
            },
            {
                title: "第4文: 理由の説明",
                description: "「その理由は(S)...である(V)」。",
                annotations: [
                    { type: 'symbol', targetId: 69, label: 'S', color: COLORS.S },
                    { type: 'arrow', fromId: 71, toId: 70, color: COLORS.REL },
                    { type: 'symbol', targetId: 72, label: 'V', color: COLORS.V },
                ],
                highlightIds: [69, 70, 71, 72],
                jpHighlightIds: [18, 23],
                mainColor: COLORS.S
            },
            {
                title: "保護となるthat節",
                description: "理由は「話すことと聞くことは(S') ... 異なっている(V')」から。",
                annotations: [
                    { type: 'symbol', targetId: 69, label: 'S', color: COLORS.S }, 
                    { type: 'symbol', targetId: 72, label: 'V', color: COLORS.V },
                    { type: 'bracket-start', targetId: 73, color: COLORS.MOD },
                    { type: 'underline', startId: 74, endId: 76, label: "S'", color: COLORS.MOD },
                    { type: 'symbol', targetId: 77, label: "V'", color: COLORS.MOD },
                ],
                highlightIds: range(73, 77),
                jpHighlightIds: [19, 22],
                mainColor: COLORS.MOD
            },
            {
                title: "differの修飾語句",
                description: "「何と(from ...)」「どのように(in ... ways)」異なるのか。",
                annotations: [
                    { type: 'symbol', targetId: 77, label: "V'", color: COLORS.MOD },
                    { type: 'arrow', fromId: 77, toId: 81, color: COLORS.GRAY },
                    { type: 'bracket-sub', startId: 81, endId: 84, label: 'M', color: COLORS.GRAY },
                ],
                highlightIds: range(78, 84),
                jpHighlightIds: [20, 21],
                mainColor: COLORS.GRAY
            },
            {
                title: "第5文: 無生物主語と形式目的語",
                description: "「この違いが、それ(it)をずっと難しくする」。'it' は形式目的語。",
                annotations: [
                    { type: 'underline', startId: 85, endId: 86, label: 'S', color: COLORS.S },
                    { type: 'symbol', targetId: 87, label: 'V', color: COLORS.V },
                    { type: 'symbol', targetId: 88, label: 'O(仮)', color: COLORS.ETC },
                    { type: 'symbol', targetId: 91, label: 'C', color: COLORS.C },
                ],
                highlightIds: [85, 86, 87, 88, 89, 90, 91],
                jpHighlightIds: [24, 26, 27],
                mainColor: COLORS.S
            },
            {
                title: "真の目的語",
                description: "真の目的語は「必要なスキルを習得すること(to acquire...)」。",
                annotations: [
                    { type: 'symbol', targetId: 87, label: 'V', color: COLORS.V },
                    { type: 'symbol', targetId: 88, label: 'O(仮)', color: COLORS.ETC },
                    { type: 'symbol', targetId: 91, label: 'C', color: COLORS.C },
                    { type: 'arrow', fromId: 88, toId: 92, color: COLORS.ETC },
                    { type: 'bracket-sub', startId: 92, endId: 96, label: 'O(真)', color: COLORS.ETC },
                ],
                highlightIds: range(92, 96),
                jpHighlightIds: [25],
                mainColor: COLORS.ETC
            }
        ];

        // --- コンポーネント本体 ---
        function EnglishParser() {
            const [currentStep, setCurrentStep] = React.useState(0);
            const [wordPositions, setWordPositions] = React.useState({});
            const containerRef = React.useRef(null);
            const canvasRef = React.useRef(null);
            const wordRefs = React.useRef([]);

            const calculatePositions = () => {
                if (!containerRef.current) return;
                
                const containerRect = containerRef.current.getBoundingClientRect();
                const computedStyle = window.getComputedStyle(containerRef.current);
                const borderLeft = parseFloat(computedStyle.borderLeftWidth) || 0;
                const borderTop = parseFloat(computedStyle.borderTopWidth) || 0;

                const positions = {};

                WORDS.forEach((_, index) => {
                    const el = wordRefs.current[index];
                    if (el) {
                        const rect = el.getBoundingClientRect();
                        
                        const relativeTop = rect.top - containerRect.top - borderTop;
                        const relativeBottom = rect.bottom - containerRect.top - borderTop;
                        const relativeLeft = rect.left - containerRect.left - borderLeft;
                        const relativeRight = rect.right - containerRect.left - borderLeft;
                        
                        positions[index] = {
                            x: relativeLeft,
                            y: relativeTop,
                            width: rect.width,
                            height: rect.height,
                            drawTop: relativeTop,
                            drawBottom: relativeBottom, 
                            left: relativeLeft,
                            right: relativeRight - 4,
                            centerX: (relativeLeft + (relativeRight - 4)) / 2
                        };
                    }
                });
                setWordPositions(positions);
            };

            React.useEffect(() => {
                calculatePositions();
                const resizeObserver = new ResizeObserver(() => calculatePositions());
                if (containerRef.current) resizeObserver.observe(containerRef.current);
                document.fonts.ready.then(() => calculatePositions());
                window.addEventListener('resize', calculatePositions);
                return () => {
                    resizeObserver.disconnect();
                    window.removeEventListener('resize', calculatePositions);
                };
            }, []);

            React.useLayoutEffect(() => {
                calculatePositions();
            }, [currentStep]);

            React.useEffect(() => {
                drawCanvas();
            }, [wordPositions, currentStep]);

            const drawCanvas = () => {
                const canvas = canvasRef.current;
                const ctx = canvas?.getContext('2d');
                if (!canvas || !ctx || Object.keys(wordPositions).length === 0) return;

                const dpr = window.devicePixelRatio || 1;
                const container = containerRef.current;
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = `${width}px`;
                canvas.style.height = `${height}px`;
                ctx.scale(dpr, dpr);

                ctx.clearRect(0, 0, width, height);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                const currentAnnotations = STEPS[currentStep].annotations;

                currentAnnotations.forEach(anim => {
                    const pos = wordPositions[anim.targetId ?? anim.startId ?? 0];
                    if (!pos) return;

                    const drawColor = anim.color || '#000';
                    ctx.strokeStyle = drawColor;
                    ctx.fillStyle = drawColor;
                    ctx.lineWidth = 2;

                    if (anim.type === 'symbol') {
                        const lineY = pos.drawBottom; 
                        ctx.beginPath();
                        ctx.moveTo(pos.left, lineY);
                        ctx.lineTo(pos.right, lineY);
                        ctx.stroke();
                        ctx.font = 'bold 14px "Inter", sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top'; 
                        ctx.fillText(anim.label || '', pos.centerX, lineY + 4);
                    }
                    if (anim.type === 'bracket-start') {
                        const topY = pos.drawTop;
                        const bottomY = pos.drawBottom;
                        const x = pos.left - 4;
                        ctx.beginPath();
                        ctx.moveTo(x + 5, topY);
                        ctx.lineTo(x, topY);
                        ctx.lineTo(x, bottomY);
                        ctx.lineTo(x + 5, bottomY);
                        ctx.stroke();
                    }
                    if (anim.type === 'bracket-full' || anim.type === 'bracket-sub') {
                        const startP = wordPositions[anim.startId];
                        const endP = wordPositions[anim.endId];
                        if (!startP || !endP) return;

                        const startTop = startP.drawTop;
                        const startBottom = startP.drawBottom;
                        const startX = startP.left - 4;
                        const endTop = endP.drawTop;
                        const endBottom = endP.drawBottom;
                        const endX = endP.right + 4;

                        ctx.beginPath();
                        ctx.moveTo(startX + 5, startTop);
                        ctx.lineTo(startX, startTop);
                        ctx.lineTo(startX, startBottom);
                        ctx.lineTo(startX + 5, startBottom);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(endX - 5, endTop);
                        ctx.lineTo(endX, endTop);
                        ctx.lineTo(endX, endBottom);
                        ctx.lineTo(endX - 5, endBottom);
                        ctx.stroke();
                        
                        if (anim.label) {
                            ctx.font = '12px sans-serif';
                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'bottom';
                            ctx.fillText(anim.label, startX, startTop - 2);
                        }
                    }
                    if (anim.type === 'arrow') {
                        const from = wordPositions[anim.fromId];
                        const to = wordPositions[anim.toId];
                        if (!from || !to) return;
                        
                        const startX = from.centerX;
                        const startY = from.drawTop; 
                        const endX = to.centerX;
                        const endY = to.drawTop; 
                        
                        const dist = Math.abs(endX - startX);
                        const archHeight = Math.min(40, dist * 0.2 + 15);
                        const cpY = Math.min(startY, endY) - archHeight;
                        
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.quadraticCurveTo((startX + endX) / 2, cpY, endX, endY);
                        ctx.stroke();

                        const cpX = (startX + endX) / 2;
                        const angle = Math.atan2(endY - cpY, endX - cpX);
                        const headLen = 8;
                        
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6), endY - headLen * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6), endY - headLen * Math.sin(angle + Math.PI / 6));
                        ctx.fillStyle = drawColor;
                        ctx.fill();
                    }
                    if (anim.type === 'slash') {
                        const p = wordPositions[anim.targetId];
                        ctx.beginPath();
                        const x = p.right + 6; 
                        const top = p.drawTop - 2;
                        const bottom = p.drawBottom + 2;
                        ctx.moveTo(x - 4, bottom);
                        ctx.lineTo(x + 4, top);
                        ctx.stroke();
                    }
                    if (anim.type === 'underline') {
                        const start = wordPositions[anim.startId];
                        const end = wordPositions[anim.endId];
                        if (!start || !end) return;
                        const lineY = Math.max(start.drawBottom, end.drawBottom) + 2;
                        ctx.beginPath();
                        ctx.setLineDash([3, 3]);
                        ctx.moveTo(start.left, lineY);
                        ctx.lineTo(end.right, lineY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        if (anim.label) {
                            ctx.font = '11px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'top';
                            ctx.fillStyle = '#64748b';
                            ctx.fillText(anim.label, (start.left + end.right) / 2, lineY + 3);
                        }
                    }
                });
            };

            const nextStep = () => {
                if (currentStep < STEPS.length - 1) {
                    setCurrentStep(c => c + 1);
                    const nextAnnotations = STEPS[currentStep + 1].annotations;
                    if (nextAnnotations.length > 0) {
                        const targetId = nextAnnotations[0].targetId ?? nextAnnotations[0].startId ?? 0;
                        const el = wordRefs.current[targetId];
                        if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            };
            const prevStep = () => {
                if (currentStep > 0) setCurrentStep(c => c - 1);
            };

            // ローディング完了したら消す
            React.useEffect(() => {
                const loadingEl = document.getElementById('loading');
                if (loadingEl) loadingEl.style.display = 'none';
            }, []);

            return (
                <div className="max-w-4xl mx-auto p-6 min-h-screen pb-32">
                    <div className="mb-6 border-b pb-4 flex justify-between items-center sticky top-0 bg-slate-50 z-20 pt-2">
                        <div>
                            <h1 className="text-2xl font-bold text-slate-800">英文解釈ビジュアライザー</h1>
                            <p className="text-slate-500 text-sm">全訳同期・カラー連動版</p>
                        </div>
                        <div className="flex gap-2">
                            <div className="bg-white px-3 py-1 rounded border shadow-sm text-sm">
                                Step {currentStep + 1} / {STEPS.length}
                            </div>
                        </div>
                    </div>

                    <div className="mb-2"><span className="text-xs font-bold text-slate-400 uppercase tracking-wider pl-1">English</span></div>
                    
                    <div ref={containerRef} className="relative bg-white rounded-xl shadow-lg border border-slate-200 p-8 mb-4 overflow-hidden">
                        <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full pointer-events-none z-10" />
                        <div className="relative z-0 text-xl leading-loose font-serif text-slate-800 tracking-wide">
                            {WORDS.map((word, i) => (
                                <span key={i}
                                    ref={el => { wordRefs.current[i] = el; }}
                                    style={{ paddingRight: i === WORDS.length - 1 ? 0 : '0.3em' }}
                                    className={`inline-block leading-tight transition-all duration-300 ${(STEPS[currentStep].highlightIds || []).includes(i) ? 'bg-yellow-300 text-slate-900 rounded-sm' : ''}`}
                                >
                                    {word.text}
                                </span>
                            ))}
                        </div>
                    </div>
                    
                    <div className="mb-6 text-right">
                        <p className="text-sm text-slate-500 font-medium italic">{SOURCE_CREDIT}</p>
                    </div>

                    <div className="mb-2"><span className="text-xs font-bold text-slate-400 uppercase tracking-wider pl-1">Japanese Translation</span></div>
                    
                    <div className="bg-slate-100 rounded-xl border border-slate-200 p-6 mb-6 text-lg leading-loose font-sans text-slate-700 shadow-inner">
                        {JP_CHUNKS.map((chunk) => {
                            const isActive = (STEPS[currentStep].jpHighlightIds || []).includes(chunk.id);
                            const activeColor = STEPS[currentStep].mainColor || '#000';
                            return (
                                <span key={chunk.id}
                                    className={`transition-all duration-300 inline-block px-0.5 rounded-sm ${isActive ? 'bg-white shadow-sm font-bold' : 'opacity-60'}`}
                                    style={{
                                        color: isActive ? activeColor : undefined,
                                        borderBottom: isActive ? `2px solid ${activeColor}` : '2px solid transparent',
                                        transform: isActive ? 'scale(1.02)' : 'scale(1)'
                                    }}
                                >
                                    {chunk.text}
                                </span>
                            );
                        })}
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 sticky bottom-6 z-20">
                        <div className="md:col-span-1 flex flex-col gap-3">
                            <div className="flex gap-2 justify-center md:justify-start">
                                <button onClick={prevStep} disabled={currentStep === 0} className="flex items-center gap-2 px-4 py-2 bg-white border border-slate-300 rounded-lg hover:bg-slate-50 disabled:opacity-50 transition-colors shadow-sm"><ChevronLeft size={18} /> 前へ</button>
                                <button onClick={nextStep} disabled={currentStep === STEPS.length - 1} className="flex items-center gap-2 px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 transition-colors shadow-md">次へ <ChevronRight size={18} /></button>
                            </div>
                            <button onClick={() => setCurrentStep(0)} className="flex items-center gap-2 text-slate-500 text-sm justify-center md:justify-start hover:text-slate-800 bg-white/80 p-1 rounded"><RefreshCw size={14} /> 最初からやり直す</button>
                        </div>
                        <div className="md:col-span-2 bg-slate-800 text-white p-6 rounded-lg shadow-lg transition-all duration-300 opacity-95 border-l-4" style={{ borderLeftColor: STEPS[currentStep].mainColor || '#3b82f6' }}>
                            <h3 className="text-lg font-bold mb-2 flex items-center gap-2" style={{ color: STEPS[currentStep].mainColor ? '#fff' : '#93c5fd' }}>
                                <span className="px-2 py-0.5 rounded text-sm font-bold text-slate-900" style={{ backgroundColor: STEPS[currentStep].mainColor || '#fff' }}>Step {currentStep + 1}</span>
                                {STEPS[currentStep].title}
                            </h3>
                            <p className="text-slate-300 leading-relaxed">{STEPS[currentStep].description}</p>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<EnglishParser />);
    </script>
</body>
</html>