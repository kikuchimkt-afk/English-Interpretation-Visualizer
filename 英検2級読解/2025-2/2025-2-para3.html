<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Mirror Test - Paragraph 3 Structure Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-serif { font-family: 'Times New Roman', Times, serif; }
        .font-sans { font-family: 'Inter', 'Noto Sans JP', sans-serif; }
    </style>
</head>
<body class="bg-slate-50 text-slate-900">
    <div id="root"></div>
    <script type="text/babel">
        // ==========================================
        // /* データ定義セクション */
        // ==========================================
        
        const SENTENCES = [
            "They also recognized themselves in photographs.",
            "In a test done after the mirror test, researchers showed the fish some pictures.",
            "When they were shown a picture of themselves with a mark on their body, they tried to remove the mark from their body.",
            "However, they did not act the same way when pictures of other fish with a mark were shown.",
            "This suggests that they recognize differences between themselves and other fish."
        ];

        const RAW_SENTENCE = SENTENCES.join(' ');
        const SOURCE_CREDIT = "出典：2025年度 第2回 英検2級 大問3B";

        const WORDS = RAW_SENTENCE.split(' ').map((word, index) => ({
            id: index,
            text: word
        }));

        const JP_CHUNKS = [
            { id: 0, text: "彼らは写真の中でも自分自身を認識しました。" },
            { id: 1, text: "ミラーテストの後に行われたテストで、研究者たちはその魚にいくつかの写真を見せました。" },
            { id: 2, text: "体に印がついた自分の写真を見せられたとき、彼らは体から印を取り除こうとしました。" },
            { id: 3, text: "しかし、印がついた他の魚の写真を見せられたときは、同じようには振る舞いませんでした。" },
            { id: 4, text: "これは、彼らが自分自身と他の魚との違いを認識していることを示唆しています。" }
        ];

        const COLORS = {
            S: '#ef4444', V: '#ef4444', O: '#ef4444', C: '#ef4444',
            REL: '#3b82f6', MOD: '#10b981', ETC: '#f97316', GRAY: '#64748b',
            CONJ: '#8b5cf6'
        };

        const range = (start, end) => Array.from({ length: end - start + 1 }, (_, i) => start + i);

        // --- インデックス計算メモ ---
        // S1: 0-5 (They...photographs.)
        // S2: 6-19 (In...pictures.) "done" is 9. "showed" is 15.
        // S3: 20-42 (When...body.) "shown" is 23. "tried" is 35. "remove" is 37.
        // S4: 43-61 (However,...shown.) "act" is 47. "same" is 49. "when" is 52.
        // S5: 62-72 (This...fish.) "suggests" is 63. "that" is 64.

        const STEPS = [
            // Sentence 1
            {
                title: "1文目：再帰代名詞と前置詞句",
                description: "recognized themselves「自分自身を認識した」。in photographs は場所を表す修飾語句です。",
                annotations: [
                    { type: 'underline', startId: 0, endId: 0, label: 'S', color: COLORS.S },
                    { type: 'bracket-sub', startId: 1, endId: 1, label: '副詞', color: COLORS.MOD },
                    { type: 'underline', startId: 2, endId: 2, label: 'V', color: COLORS.V },
                    { type: 'underline', startId: 3, endId: 3, label: 'O', color: COLORS.O },
                    { type: 'bracket-sub', startId: 4, endId: 5, label: 'M (場所)', color: COLORS.MOD },
                ],
                highlightIds: range(0, 5),
                jpHighlightIds: [0],
                mainColor: COLORS.S
            },
            // Sentence 2
            {
                title: "2文目：過去分詞の後置修飾",
                description: "test done after... 「〜の後に行われたテスト」。done は過去分詞で test を後ろから修飾しています。",
                annotations: [
                    { type: 'bracket-sub', startId: 6, endId: 13, label: 'M (場所/時)', color: COLORS.MOD },
                    { type: 'bracket-sub', startId: 9, endId: 13, label: '形容詞句', color: COLORS.MOD },
                    { type: 'arrow', fromId: 9, toId: 8, color: COLORS.MOD }, // done -> test
                    { type: 'underline', startId: 14, endId: 14, label: 'S', color: COLORS.S },
                    { type: 'underline', startId: 15, endId: 15, label: 'V', color: COLORS.V },
                ],
                highlightIds: range(6, 19),
                jpHighlightIds: [1],
                mainColor: COLORS.MOD
            },
            {
                title: "2文目：SVOO（第4文型）",
                description: "showed the fish some pictures 「その魚に(O1) いくつかの写真を(O2) 見せた」。",
                annotations: [
                    { type: 'underline', startId: 15, endId: 15, label: 'V', color: COLORS.V },
                    { type: 'underline', startId: 16, endId: 17, label: 'O1 (〜に)', color: COLORS.O },
                    { type: 'underline', startId: 18, endId: 19, label: 'O2 (〜を)', color: COLORS.O },
                ],
                highlightIds: range(6, 19),
                jpHighlightIds: [1],
                mainColor: COLORS.V
            },
            // Sentence 3
            {
                title: "3文目：受動態を含むWhen節",
                description: "were shown a picture 「写真を見せられた」。能動態 show O1 O2 の受動態なので、O2(a picture)が後ろに残っています。",
                annotations: [
                    { type: 'bracket-sub', startId: 20, endId: 33, label: 'M (時)', color: COLORS.MOD },
                    { type: 'underline', startId: 20, endId: 20, label: '接続詞', color: COLORS.CONJ },
                    { type: 'underline', startId: 21, endId: 21, label: 'S’', color: COLORS.S },
                    { type: 'underline', startId: 22, endId: 23, label: 'V’ (受動態)', color: COLORS.V },
                    { type: 'underline', startId: 24, endId: 33, label: 'O’ (残留目的語)', color: COLORS.O },
                ],
                highlightIds: range(20, 42),
                jpHighlightIds: [2],
                mainColor: COLORS.MOD
            },
            {
                title: "3文目：不定詞の目的語",
                description: "tried to remove... 「〜しようとした」。to remove 以下は tried の目的語となる名詞的用法です。",
                annotations: [
                    { type: 'underline', startId: 34, endId: 34, label: 'S', color: COLORS.S },
                    { type: 'underline', startId: 35, endId: 35, label: 'V', color: COLORS.V },
                    { type: 'bracket-full', startId: 36, endId: 42, label: 'O (不定詞)', color: COLORS.O },
                ],
                highlightIds: range(20, 42),
                jpHighlightIds: [2],
                mainColor: COLORS.O
            },
            // Sentence 4
            {
                title: "4文目：副詞的目的格",
                description: "act the same way 「同じように振る舞う」。the same way は名詞ですが、副詞的に動詞 act を修飾しています。",
                annotations: [
                    { type: 'bracket-sub', startId: 43, endId: 43, label: '接続副詞', color: COLORS.CONJ },
                    { type: 'underline', startId: 44, endId: 44, label: 'S', color: COLORS.S },
                    { type: 'underline', startId: 45, endId: 47, label: 'V', color: COLORS.V },
                    { type: 'bracket-sub', startId: 48, endId: 50, label: 'M (様態)', color: COLORS.MOD }, // the same way
                    { type: 'arrow', fromId: 48, toId: 47, color: COLORS.MOD },
                ],
                highlightIds: range(43, 61),
                jpHighlightIds: [3],
                mainColor: COLORS.MOD
            },
            {
                title: "4文目：When節の中の修飾関係",
                description: "pictures of other fish with a mark 「印がついた他の魚の写真」。前置詞句が重なり、主語picturesを修飾しています。",
                annotations: [
                    { type: 'bracket-sub', startId: 51, endId: 61, label: 'M (時)', color: COLORS.MOD },
                    { type: 'underline', startId: 52, endId: 59, label: 'S’', color: COLORS.S }, // pictures...mark
                    { type: 'bracket-sub', startId: 57, endId: 59, label: '形容詞句', color: COLORS.MOD }, // with a mark
                    { type: 'arrow', fromId: 57, toId: 55, color: COLORS.MOD }, // with -> fish
                    { type: 'bracket-sub', startId: 54, endId: 59, label: '形容詞句', color: COLORS.MOD }, // of other fish...
                    { type: 'arrow', fromId: 54, toId: 52, color: COLORS.MOD }, // of -> pictures
                    { type: 'underline', startId: 60, endId: 61, label: 'V’ (受動態)', color: COLORS.V },
                ],
                highlightIds: range(43, 61),
                jpHighlightIds: [3],
                mainColor: COLORS.S
            },
            // Sentence 5
            {
                title: "5文目：That節",
                description: "suggests that... 「〜ということを示唆する」。that節全体が動詞の目的語になっています。",
                annotations: [
                    { type: 'underline', startId: 62, endId: 62, label: 'S', color: COLORS.S },
                    { type: 'underline', startId: 63, endId: 63, label: 'V', color: COLORS.V },
                    { type: 'bracket-full', startId: 64, endId: 72, label: 'O (名詞節)', color: COLORS.O },
                    { type: 'underline', startId: 64, endId: 64, label: '接続詞', color: COLORS.CONJ },
                    { type: 'underline', startId: 65, endId: 65, label: 'S’', color: COLORS.S },
                    { type: 'underline', startId: 66, endId: 66, label: 'V’', color: COLORS.V },
                    { type: 'underline', startId: 67, endId: 72, label: 'O’', color: COLORS.O },
                ],
                highlightIds: range(62, 72),
                jpHighlightIds: [4],
                mainColor: COLORS.CONJ
            }
        ];

        // ==========================================
        // /* ロジックセクション */
        // ==========================================
        
        function EnglishParser() {
            const [currentStep, setCurrentStep] = React.useState(0);
            const [wordPositions, setWordPositions] = React.useState({});
            const containerRef = React.useRef(null);
            const canvasRef = React.useRef(null);
            const wordRefs = React.useRef([]);

            const calculatePositions = () => {
                if (!containerRef.current) return;
                const containerRect = containerRef.current.getBoundingClientRect();
                const computedStyle = window.getComputedStyle(containerRef.current);
                const borderLeft = parseFloat(computedStyle.borderLeftWidth) || 0;
                const borderTop = parseFloat(computedStyle.borderTopWidth) || 0;
                const positions = {};

                WORDS.forEach((_, index) => {
                    const el = wordRefs.current[index];
                    if (el) {
                        const rect = el.getBoundingClientRect();
                        positions[index] = {
                            x: rect.left - containerRect.left - borderLeft,
                            y: rect.top - containerRect.top - borderTop,
                            width: rect.width, height: rect.height,
                            drawTop: rect.top - containerRect.top - borderTop,
                            drawBottom: rect.bottom - containerRect.top - borderTop,
                            left: rect.left - containerRect.left - borderLeft,
                            right: rect.right - containerRect.left - borderLeft - 3,
                            centerX: (rect.left + rect.right - 2 * (containerRect.left + borderLeft)) / 2
                        };
                    }
                });
                setWordPositions(positions);
            };

            React.useEffect(() => {
                calculatePositions();
                const observer = new ResizeObserver(calculatePositions);
                if (containerRef.current) observer.observe(containerRef.current);
                document.fonts.ready.then(calculatePositions);
                window.addEventListener('resize', calculatePositions);
                return () => { observer.disconnect(); window.removeEventListener('resize', calculatePositions); };
            }, []);

            React.useLayoutEffect(calculatePositions, [currentStep]);
            React.useEffect(() => drawCanvas(), [wordPositions, currentStep]);

            const drawCanvas = () => {
                const canvas = canvasRef.current;
                const ctx = canvas?.getContext('2d');
                if (!canvas || !ctx || Object.keys(wordPositions).length === 0) return;

                const dpr = window.devicePixelRatio || 1;
                const container = containerRef.current;
                canvas.width = container.clientWidth * dpr;
                canvas.height = container.clientHeight * dpr;
                canvas.style.width = `${container.clientWidth}px`;
                canvas.style.height = `${container.clientHeight}px`;
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, container.clientWidth, container.clientHeight);
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';

                const annotations = STEPS[currentStep].annotations || [];
                annotations.forEach(anim => {
                    const pos = wordPositions[anim.targetId ?? anim.startId ?? 0];
                    if (!pos) return;
                    
                    ctx.strokeStyle = anim.color || '#000';
                    ctx.fillStyle = anim.color || '#000';
                    ctx.lineWidth = 2;

                    if (anim.type === 'insert-text') {
                        const x = pos.left - 5;
                        const y = pos.drawTop - 10; 
                        ctx.font = 'bold 12px "Inter"';
                        ctx.textAlign = 'right';
                        ctx.fillStyle = anim.color || '#000'; 
                        ctx.fillText(anim.text, x + 10, y + 10);
                        ctx.beginPath();
                        ctx.moveTo(pos.left - 2, pos.drawBottom);
                        ctx.lineTo(pos.left + 2, pos.drawBottom);
                        ctx.lineTo(pos.left, pos.drawTop + 2); 
                        ctx.strokeStyle = anim.color || '#000';
                        ctx.stroke();
                    }
                    else if (anim.type === 'symbol') {
                        const y = pos.drawBottom + 2;
                        ctx.beginPath(); ctx.moveTo(pos.left, y); ctx.lineTo(pos.right, y); ctx.stroke();
                        ctx.font = 'bold 14px "Inter"'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                        ctx.fillStyle = anim.color || '#000';
                        ctx.fillText(anim.label || '', pos.centerX, y + 2);
                    } 
                    else if (anim.type === 'underline') {
                        const lines = {};
                        for (let i = anim.startId; i <= anim.endId; i++) {
                            const p = wordPositions[i];
                            if (!p) continue;
                            const yKey = Math.round(p.drawBottom);
                            if (!lines[yKey]) lines[yKey] = { left: p.left, right: p.right, bottom: p.drawBottom };
                            else {
                                lines[yKey].left = Math.min(lines[yKey].left, p.left);
                                lines[yKey].right = Math.max(lines[yKey].right, p.right);
                                lines[yKey].bottom = Math.max(lines[yKey].bottom, p.drawBottom);
                            }
                        }
                        Object.values(lines).forEach((line) => {
                            const y = line.bottom + 2; 
                            ctx.beginPath(); 
                            if(anim.label && (anim.label.includes('節') || anim.label.includes('受動') || anim.label.includes('副詞') || anim.label.includes('不定詞') || anim.label.includes('接続詞'))) ctx.setLineDash([2, 2]);
                            ctx.moveTo(line.left, y); ctx.lineTo(line.right, y); ctx.stroke();
                        });
                        ctx.setLineDash([]);
                        if (anim.label) {
                            const endPos = wordPositions[anim.endId];
                            if(endPos) {
                                ctx.font = '10px "Inter"'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                                ctx.fillStyle = anim.color || '#000';
                                ctx.fillText(anim.label, endPos.right + 2, endPos.drawBottom); 
                            }
                        }
                    } 
                    else if (anim.type === 'arrow') {
                        const from = wordPositions[anim.fromId];
                        const to = wordPositions[anim.toId];
                        if (from && to) {
                            const sx = from.centerX, sy = from.drawTop, ex = to.centerX, ey = to.drawTop;
                            const cpY = Math.min(sy, ey) - 15;
                            ctx.beginPath(); ctx.moveTo(sx, sy - 2); ctx.quadraticCurveTo((sx+ex)/2, cpY, ex, ey - 2); ctx.stroke();
                            const angle = Math.atan2(ey - 2 - cpY, ex - (sx+ex)/2);
                            ctx.beginPath(); ctx.moveTo(ex, ey - 2);
                            ctx.lineTo(ex - 5 * Math.cos(angle - Math.PI/6), ey - 2 - 5 * Math.sin(angle - Math.PI/6));
                            ctx.lineTo(ex - 5 * Math.cos(angle + Math.PI/6), ey - 2 - 5 * Math.sin(angle + Math.PI/6));
                            ctx.fillStyle = anim.color || '#000';
                            ctx.fill();
                        }
                    } 
                    else if (anim.type === 'bracket-start' || anim.type === 'bracket-full' || anim.type === 'bracket-sub') {
                        const endPos = wordPositions[anim.endId] || pos;
                        const isMultiLine = Math.abs(pos.drawTop - endPos.drawTop) > 20;

                        if (isMultiLine) {
                            const top1 = pos.drawTop - 2;
                            const bottom1 = pos.drawBottom + 2;
                            const left1 = pos.left - 3;
                            ctx.beginPath();
                            ctx.moveTo(left1 + 4, top1); ctx.lineTo(left1, top1); ctx.lineTo(left1, bottom1); ctx.lineTo(left1 + 4, bottom1);
                            ctx.stroke();

                            const top2 = endPos.drawTop - 2;
                            const bottom2 = endPos.drawBottom + 2;
                            const right2 = endPos.right + 3;
                            if (anim.type !== 'bracket-start') {
                                ctx.beginPath();
                                ctx.moveTo(right2 - 4, top2); ctx.lineTo(right2, top2); ctx.lineTo(right2, bottom2); ctx.lineTo(right2 - 4, bottom2);
                                ctx.stroke();
                            }
                        } else {
                            const top = Math.min(pos.drawTop, endPos.drawTop) - 2;
                            const bottom = Math.max(pos.drawBottom, endPos.drawBottom) + 2;
                            const left = pos.left - 3;
                            const right = endPos.right + 3;
                            ctx.beginPath();
                            ctx.moveTo(left + 4, top); ctx.lineTo(left, top); ctx.lineTo(left, bottom); ctx.lineTo(left + 4, bottom);
                            ctx.stroke();
                            if (anim.type !== 'bracket-start') {
                                ctx.beginPath();
                                ctx.moveTo(right - 4, top); ctx.lineTo(right, top); ctx.lineTo(right, bottom); ctx.lineTo(right - 4, bottom);
                                ctx.stroke();
                            }
                        }
                        if (anim.label) {
                             ctx.font = '11px "Inter"'; ctx.textAlign = 'left'; ctx.fillStyle = anim.color || '#000';
                             ctx.fillText(anim.label, pos.left - 3, pos.drawTop - 12);
                        }
                    }
                });
            };

            const nextStep = () => { if (currentStep < STEPS.length - 1) setCurrentStep(c => c + 1); };
            const prevStep = () => { if (currentStep > 0) setCurrentStep(c => c - 1); };

            const ChevronRight = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="9 18 15 12 9 6"></polyline></svg>;
            const ChevronLeft = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="15 18 9 12 15 6"></polyline></svg>;
            const RefreshCw = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;

            return (
                <div className="max-w-4xl mx-auto p-4 md:p-6 min-h-screen pb-32">
                    <div className="mb-6 border-b pb-4 flex justify-between items-center sticky top-0 bg-slate-50 z-20 pt-2">
                        <div>
                            <h1 className="text-xl md:text-2xl font-bold text-slate-800">The Mirror Test (Paragraph 3)</h1>
                            <p className="text-slate-500 text-xs md:text-sm">{SOURCE_CREDIT}</p>
                        </div>
                        <div className="bg-white px-3 py-1 rounded border shadow-sm text-sm font-mono">{currentStep + 1} / {STEPS.length}</div>
                    </div>
                    <div ref={containerRef} className="relative bg-white rounded-xl shadow-lg border border-slate-200 p-6 md:p-8 mb-4 overflow-hidden">
                        <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full pointer-events-none z-10" />
                        <div className="relative z-0 text-lg md:text-xl font-serif text-slate-800 tracking-wide" style={{ lineHeight: '1.8' }}>
                            {WORDS.map((word, i) => (
                                <span key={i} ref={el => { wordRefs.current[i] = el; }} className={`inline-block transition-colors duration-300 ${(STEPS[currentStep].highlightIds || []).includes(i) ? 'bg-yellow-200/70 rounded-sm' : ''}`} style={{ paddingRight: '0.3em', lineHeight: '1.35' }}>{word.text}</span>
                            ))}
                        </div>
                    </div>
                    <div className="mb-2"><span className="text-xs font-bold text-slate-400 uppercase pl-1">Translation</span></div>
                    <div className="bg-slate-100 rounded-xl border border-slate-200 p-5 mb-6 text-base md:text-lg leading-loose font-sans text-slate-700">
                        {JP_CHUNKS.map((chunk) => {
                            const isActive = (STEPS[currentStep].jpHighlightIds || []).includes(chunk.id);
                            return (
                                <span key={chunk.id} className={`transition-all duration-300 inline-block px-1 rounded-sm ${isActive ? 'bg-white shadow-sm font-bold text-slate-900' : 'opacity-50'}`} style={{ borderBottom: isActive ? `2px solid ${STEPS[currentStep].mainColor}` : '2px solid transparent' }}>{chunk.text}</span>
                            );
                        })}
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 sticky bottom-4 z-30">
                        <div className="md:col-span-1 flex flex-row md:flex-col gap-2 justify-between md:justify-start">
                            <div className="flex gap-2 w-full">
                                <button onClick={prevStep} disabled={currentStep === 0} className="flex-1 flex items-center justify-center gap-2 px-4 py-3 bg-white border border-slate-300 rounded-lg hover:bg-slate-50 disabled:opacity-50 shadow-sm"><ChevronLeft/> Prev</button>
                                <button onClick={nextStep} disabled={currentStep === STEPS.length - 1} className="flex-1 flex items-center justify-center gap-2 px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 shadow-md">Next <ChevronRight/></button>
                            </div>
                            <button onClick={() => setCurrentStep(0)} className="hidden md:flex items-center gap-2 text-slate-500 text-sm p-2 hover:bg-slate-100 rounded self-start"><RefreshCw/> Reset</button>
                        </div>
                        <div className="md:col-span-2 bg-slate-800 text-white p-5 rounded-lg shadow-xl border-l-4" style={{ borderLeftColor: STEPS[currentStep].mainColor || '#3b82f6' }}>
                            <h3 className="font-bold mb-1 text-blue-200">{STEPS[currentStep].title}</h3>
                            <p className="text-slate-300 text-sm md:text-base">{STEPS[currentStep].description}</p>
                        </div>
                    </div>
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<EnglishParser />);
    </script>
</body>
</html>