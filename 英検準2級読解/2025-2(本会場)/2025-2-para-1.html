<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>英検準2級 構文解釈 (2025-2 Salt) - Para 1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-serif { font-family: 'Times New Roman', Times, serif; }
        .font-sans { font-family: 'Inter', 'Noto Sans JP', sans-serif; }
    </style>
</head>
<body class="bg-slate-50 text-slate-900">
    <div id="root"></div>
    <script type="text/babel">
        // ==========================================
        // /* データ定義セクション */
        // ==========================================
        
        const SENTENCES = [
            "Salt is necessary for humans to survive.",
            "It is a common item widely available today.",
            "Because it gives extra flavor to meals, it may be simply considered an item used for cooking.",
            "However, it is not only used to add flavor.",
            "Salt was seen very differently in the past.",
            "With many historical factors, salt was important in many ways in various cultures around the world."
        ];

        const RAW_SENTENCE = SENTENCES.join(' ');
        const SOURCE_CREDIT = "出典：英検準2級 2025年度 第2回 大問4B (本会場)";

        // カンマやピリオドを含んだ状態で単語分割
        const WORDS = RAW_SENTENCE.split(' ').map((word, index) => ({
            id: index,
            text: word
        }));

        // 文脈に即した自然な日本語訳
        const JP_CHUNKS = [
            { id: 0, text: "塩は人間が生きていくために不可欠です。" },
            { id: 1, text: "それは今日、広く入手可能なありふれた品目です。" },
            { id: 2, text: "食事に余分な風味を与えるため、" },
            { id: 3, text: "単に料理に使われる品目だと考えられるかもしれません。" },
            { id: 4, text: "しかし、風味を加えるためだけに使われるわけではありません。" },
            { id: 5, text: "過去においては、塩は全く異なって見られていました。" },
            { id: 6, text: "多くの歴史的要因により、" },
            { id: 7, text: "塩は世界中の様々な文化において、多くの点で重要でした。" }
        ];

        const COLORS = {
            S: '#ef4444', V: '#ef4444', O: '#ef4444', C: '#ef4444',
            REL: '#3b82f6', MOD: '#10b981', ETC: '#f97316', GRAY: '#64748b',
            CONJ: '#8b5cf6'
        };

        const range = (start, end) => Array.from({ length: end - start + 1 }, (_, i) => start + i);

        /* Words Index Map:
           0-6: Salt is necessary for humans to survive.
           7-14: It is a common item widely available today.
           15-31: Because it gives extra flavor to meals, it may be simply considered an item used for cooking.
             (Because:15, meals,:21, it:22, cooking.:31)
           32-40: However, it is not only used to add flavor.
           41-48: Salt was seen very differently in the past.
           49-64: With many historical factors, salt was important in many ways in various cultures around the world.
        */

        const STEPS = [
            {
                title: "1文目: 基本構造と不定詞",
                description: "SVCの第2文型です。「for humans」は不定詞「to survive」の意味上の主語になっています。",
                annotations: [
                    { type: 'symbol', label: 'S', startId: 0, color: COLORS.S },
                    { type: 'symbol', label: 'V', startId: 1, color: COLORS.V },
                    { type: 'symbol', label: 'C', startId: 2, color: COLORS.C },
                    { type: 'bracket-sub', label: '意味上の主語+不定詞', startId: 3, endId: 6, color: COLORS.MOD }
                ],
                highlightIds: range(0, 6),
                jpHighlightIds: [0],
                mainColor: COLORS.S
            },
            {
                title: "2文目: 形容詞句による後置修飾",
                description: "「widely available today」という形容詞のまとまりが、後ろから「item」を修飾しています。",
                annotations: [
                    { type: 'symbol', label: 'S', startId: 7, color: COLORS.S },
                    { type: 'symbol', label: 'V', startId: 8, color: COLORS.V },
                    { type: 'underline', label: 'C', startId: 9, endId: 11, color: COLORS.C },
                    { type: 'bracket-sub', label: '形容詞句', startId: 12, endId: 14, color: COLORS.MOD },
                    { type: 'arrow', fromId: 12, toId: 11, color: COLORS.MOD }
                ],
                highlightIds: range(7, 14),
                jpHighlightIds: [1],
                mainColor: COLORS.MOD
            },
            {
                title: "3文目(前半): 理由を表す副詞節",
                description: "接続詞 Because が導く副詞節です。「～なので」と理由を説明しています。",
                annotations: [
                    { type: 'bracket-start', label: '副詞節(理由)', startId: 15, endId: 21, color: COLORS.CONJ },
                    { type: 'symbol', label: 'S', startId: 16, color: COLORS.S },
                    { type: 'symbol', label: 'V', startId: 17, color: COLORS.V },
                    { type: 'symbol', label: 'O', startId: 18, endId: 19, color: COLORS.O }
                ],
                highlightIds: range(15, 21),
                jpHighlightIds: [2],
                mainColor: COLORS.CONJ
            },
            {
                title: "3文目(後半): 受動態と過去分詞",
                description: "「may be considered」は受動態。「used for cooking」は過去分詞で、前の「item」を修飾しています。",
                annotations: [
                    { type: 'symbol', label: 'S', startId: 22, color: COLORS.S },
                    { type: 'underline', label: 'V(受動態)', startId: 23, endId: 26, color: COLORS.V },
                    { type: 'symbol', label: 'C', startId: 27, endId: 28, color: COLORS.C },
                    { type: 'arrow', fromId: 29, toId: 28, color: COLORS.MOD },
                    { type: 'bracket-sub', label: '過去分詞句', startId: 29, endId: 31, color: COLORS.MOD }
                ],
                highlightIds: range(22, 31),
                jpHighlightIds: [3],
                mainColor: COLORS.V
            },
            {
                title: "4文目: 接続副詞と目的の不定詞",
                description: "Howeverは逆接の接続副詞。「to add flavor」は「風味を加えるために」という目的を表す副詞的用法です。",
                annotations: [
                    { type: 'insert-text', text: '接続副詞', targetId: 32, color: COLORS.CONJ },
                    { type: 'symbol', label: 'S', startId: 33, color: COLORS.S },
                    { type: 'underline', label: 'V(受動態)', startId: 34, endId: 37, color: COLORS.V },
                    { type: 'bracket-sub', label: '目的', startId: 38, endId: 40, color: COLORS.MOD }
                ],
                highlightIds: range(32, 40),
                jpHighlightIds: [4],
                mainColor: COLORS.CONJ
            },
            {
                title: "5文目: 受動態と時制",
                description: "「was seen」は受動態の過去形。「in the past」が文末にあり、過去の状況であることを強調しています。",
                annotations: [
                    { type: 'symbol', label: 'S', startId: 41, color: COLORS.S },
                    { type: 'symbol', label: 'V', startId: 42, endId: 43, color: COLORS.V },
                    { type: 'bracket-sub', label: '様態', startId: 44, endId: 45, color: COLORS.MOD },
                    { type: 'bracket-sub', label: '時', startId: 46, endId: 48, color: COLORS.MOD }
                ],
                highlightIds: range(41, 48),
                jpHighlightIds: [5],
                mainColor: COLORS.V
            },
            {
                title: "6文目: 前置詞句と文構造",
                description: "文頭の「With...」は原因や付帯状況を表します。主節はSVC構造で、後ろに修飾語句が続いています。",
                annotations: [
                    { type: 'bracket-sub', label: '前置詞句', startId: 49, endId: 52, color: COLORS.MOD },
                    { type: 'symbol', label: 'S', startId: 53, color: COLORS.S },
                    { type: 'symbol', label: 'V', startId: 54, color: COLORS.V },
                    { type: 'symbol', label: 'C', startId: 55, color: COLORS.C },
                    { type: 'underline', label: '修飾語句', startId: 56, endId: 64, color: COLORS.MOD }
                ],
                highlightIds: range(49, 64),
                jpHighlightIds: [6, 7],
                mainColor: COLORS.S
            }
        ];

        // ==========================================
        // /* ロジックセクション */
        // ==========================================
        
        function EnglishParser() {
            const [currentStep, setCurrentStep] = React.useState(0);
            const [wordPositions, setWordPositions] = React.useState({});
            const containerRef = React.useRef(null);
            const canvasRef = React.useRef(null);
            const wordRefs = React.useRef([]);

            const calculatePositions = () => {
                if (!containerRef.current) return;
                const containerRect = containerRef.current.getBoundingClientRect();
                const computedStyle = window.getComputedStyle(containerRef.current);
                const borderLeft = parseFloat(computedStyle.borderLeftWidth) || 0;
                const borderTop = parseFloat(computedStyle.borderTopWidth) || 0;
                const positions = {};

                WORDS.forEach((_, index) => {
                    const el = wordRefs.current[index];
                    if (el) {
                        const rect = el.getBoundingClientRect();
                        positions[index] = {
                            x: rect.left - containerRect.left - borderLeft,
                            y: rect.top - containerRect.top - borderTop,
                            width: rect.width, height: rect.height,
                            drawTop: rect.top - containerRect.top - borderTop,
                            drawBottom: rect.bottom - containerRect.top - borderTop,
                            left: rect.left - containerRect.left - borderLeft,
                            right: rect.right - containerRect.left - borderLeft - 3,
                            centerX: (rect.left + rect.right - 2 * (containerRect.left + borderLeft)) / 2
                        };
                    }
                });
                setWordPositions(positions);
            };

            React.useEffect(() => {
                calculatePositions();
                const observer = new ResizeObserver(calculatePositions);
                if (containerRef.current) observer.observe(containerRef.current);
                document.fonts.ready.then(calculatePositions);
                window.addEventListener('resize', calculatePositions);
                return () => { observer.disconnect(); window.removeEventListener('resize', calculatePositions); };
            }, []);

            React.useLayoutEffect(calculatePositions, [currentStep]);
            React.useEffect(() => drawCanvas(), [wordPositions, currentStep]);

            const drawCanvas = () => {
                const canvas = canvasRef.current;
                const ctx = canvas?.getContext('2d');
                if (!canvas || !ctx || Object.keys(wordPositions).length === 0) return;

                const dpr = window.devicePixelRatio || 1;
                const container = containerRef.current;
                canvas.width = container.clientWidth * dpr;
                canvas.height = container.clientHeight * dpr;
                canvas.style.width = `${container.clientWidth}px`;
                canvas.style.height = `${container.clientHeight}px`;
                ctx.scale(dpr, dpr);
                ctx.clearRect(0, 0, container.clientWidth, container.clientHeight);
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';

                const annotations = STEPS[currentStep].annotations || [];
                annotations.forEach(anim => {
                    const startPos = wordPositions[anim.startId ?? anim.targetId ?? 0];
                    if (!startPos) return;
                    
                    ctx.strokeStyle = anim.color || '#000';
                    ctx.fillStyle = anim.color || '#000';
                    ctx.lineWidth = 2;

                    if (anim.type === 'insert-text') {
                        const x = startPos.left - 5;
                        const y = startPos.drawTop - 10; 
                        ctx.font = 'bold 12px "Inter"';
                        ctx.textAlign = 'right';
                        ctx.fillText(anim.text, x + 10, y + 10);
                        ctx.beginPath();
                        ctx.moveTo(startPos.left - 2, startPos.drawBottom);
                        ctx.lineTo(startPos.left + 2, startPos.drawBottom);
                        ctx.lineTo(startPos.left, startPos.drawTop + 2); 
                        ctx.stroke();
                    }
                    else if (anim.type === 'symbol') {
                        const endPos = anim.endId ? wordPositions[anim.endId] : startPos;
                        const y = startPos.drawBottom + 2;
                        
                        if (anim.endId && anim.endId !== anim.startId) {
                             const lines = {};
                             for (let i = anim.startId; i <= anim.endId; i++) {
                                 const p = wordPositions[i];
                                 if (!p) continue;
                                 const yKey = Math.round(p.drawBottom);
                                 if (!lines[yKey]) lines[yKey] = { left: p.left, right: p.right };
                                 else {
                                     lines[yKey].left = Math.min(lines[yKey].left, p.left);
                                     lines[yKey].right = Math.max(lines[yKey].right, p.right);
                                 }
                             }
                             Object.values(lines).forEach(l => {
                                 ctx.beginPath(); ctx.moveTo(l.left, y); ctx.lineTo(l.right, y); ctx.stroke();
                             });
                             const center = (startPos.left + endPos.right) / 2; 
                             ctx.font = 'bold 14px "Inter"'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                             ctx.fillText(anim.label || '', center, y + 2);
                        } else {
                            ctx.beginPath(); ctx.moveTo(startPos.left, y); ctx.lineTo(startPos.right, y); ctx.stroke();
                            ctx.font = 'bold 14px "Inter"'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                            ctx.fillText(anim.label || '', startPos.centerX, y + 2);
                        }
                    } 
                    else if (anim.type === 'underline') {
                        const lines = {};
                        for (let i = anim.startId; i <= anim.endId; i++) {
                            const p = wordPositions[i];
                            if (!p) continue;
                            const yKey = Math.round(p.drawBottom);
                            if (!lines[yKey]) lines[yKey] = { left: p.left, right: p.right, bottom: p.drawBottom };
                            else {
                                lines[yKey].left = Math.min(lines[yKey].left, p.left);
                                lines[yKey].right = Math.max(lines[yKey].right, p.right);
                                lines[yKey].bottom = Math.max(lines[yKey].bottom, p.drawBottom);
                            }
                        }
                        Object.values(lines).forEach((line) => {
                            const y = line.bottom + 2; 
                            ctx.beginPath(); 
                            if(anim.label && (anim.label.includes('節') || anim.label.includes('受動') || anim.label.includes('副詞') || anim.label.includes('修飾'))) ctx.setLineDash([2, 2]);
                            ctx.moveTo(line.left, y); ctx.lineTo(line.right, y); ctx.stroke();
                        });
                        ctx.setLineDash([]);
                        if (anim.label) {
                            const endPos = wordPositions[anim.endId];
                            if(endPos) {
                                ctx.font = '10px "Inter"'; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                                ctx.fillText(anim.label, endPos.right + 2, endPos.drawBottom); 
                            }
                        }
                    } 
                    else if (anim.type === 'arrow') {
                        const from = wordPositions[anim.fromId];
                        const to = wordPositions[anim.toId];
                        if (from && to) {
                            const sx = from.centerX, sy = from.drawTop, ex = to.centerX, ey = to.drawTop;
                            const cpY = Math.min(sy, ey) - 15;
                            ctx.beginPath(); ctx.moveTo(sx, sy - 2); ctx.quadraticCurveTo((sx+ex)/2, cpY, ex, ey - 2); ctx.stroke();
                            const angle = Math.atan2(ey - 2 - cpY, ex - (sx+ex)/2);
                            ctx.beginPath(); ctx.moveTo(ex, ey - 2);
                            ctx.lineTo(ex - 5 * Math.cos(angle - Math.PI/6), ey - 2 - 5 * Math.sin(angle - Math.PI/6));
                            ctx.lineTo(ex - 5 * Math.cos(angle + Math.PI/6), ey - 2 - 5 * Math.sin(angle + Math.PI/6));
                            ctx.fill();
                        }
                    } 
                    else if (anim.type.startsWith('bracket')) {
                        const endPos = wordPositions[anim.endId] || startPos;
                        const isMultiLine = Math.abs(startPos.drawTop - endPos.drawTop) > 20;

                        if (isMultiLine) {
                            const top1 = startPos.drawTop - 2;
                            const bottom1 = startPos.drawBottom + 2;
                            const left1 = startPos.left - 3;
                            ctx.beginPath();
                            ctx.moveTo(left1 + 4, top1); ctx.lineTo(left1, top1); ctx.lineTo(left1, bottom1); ctx.lineTo(left1 + 4, bottom1);
                            ctx.stroke();

                            const top2 = endPos.drawTop - 2;
                            const bottom2 = endPos.drawBottom + 2;
                            const right2 = endPos.right + 3;
                            
                            if (anim.type !== 'bracket-start') {
                                ctx.beginPath();
                                ctx.moveTo(right2 - 4, top2); ctx.lineTo(right2, top2); ctx.lineTo(right2, bottom2); ctx.lineTo(right2 - 4, bottom2);
                                ctx.stroke();
                            }
                        } else {
                            const top = Math.min(startPos.drawTop, endPos.drawTop) - 2;
                            const bottom = Math.max(startPos.drawBottom, endPos.drawBottom) + 2;
                            const left = startPos.left - 3;
                            const right = endPos.right + 3;
                            ctx.beginPath();
                            ctx.moveTo(left + 4, top); ctx.lineTo(left, top); ctx.lineTo(left, bottom); ctx.lineTo(left + 4, bottom);
                            ctx.stroke();
                            if (anim.type !== 'bracket-start') {
                                ctx.beginPath();
                                ctx.moveTo(right - 4, top); ctx.lineTo(right, top); ctx.lineTo(right, bottom); ctx.lineTo(right - 4, bottom);
                                ctx.stroke();
                            }
                        }
                        if (anim.label) {
                             ctx.font = '11px "Inter"'; ctx.textAlign = 'left';
                             ctx.fillText(anim.label, startPos.left - 3, startPos.drawTop - 12);
                        }
                    }
                });
            };

            const nextStep = () => { if (currentStep < STEPS.length - 1) setCurrentStep(c => c + 1); };
            const prevStep = () => { if (currentStep > 0) setCurrentStep(c => c - 1); };

            const ChevronRight = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="9 18 15 12 9 6"></polyline></svg>;
            const ChevronLeft = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="15 18 9 12 15 6"></polyline></svg>;
            const RefreshCw = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>;

            return (
                <div className="max-w-4xl mx-auto p-4 md:p-6 min-h-screen pb-32">
                    <div className="mb-6 border-b pb-4 flex justify-between items-center sticky top-0 bg-slate-50 z-20 pt-2">
                        <div>
                            <h1 className="text-xl md:text-2xl font-bold text-slate-800">英検準2級 長文解釈 (Salt - Para 1)</h1>
                            <p className="text-slate-500 text-xs md:text-sm">{SOURCE_CREDIT}</p>
                        </div>
                        <div className="bg-white px-3 py-1 rounded border shadow-sm text-sm font-mono">{currentStep + 1} / {STEPS.length}</div>
                    </div>
                    <div ref={containerRef} className="relative bg-white rounded-xl shadow-lg border border-slate-200 p-6 md:p-8 mb-4 overflow-hidden">
                        <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full pointer-events-none z-10" />
                        <div className="relative z-0 text-lg md:text-xl font-serif text-slate-800 tracking-wide" style={{ lineHeight: '1.8' }}>
                            {WORDS.map((word, i) => (
                                <span key={i} ref={el => { wordRefs.current[i] = el; }} className={`inline-block transition-colors duration-300 ${(STEPS[currentStep].highlightIds || []).includes(i) ? 'bg-yellow-200/70 rounded-sm' : ''}`} style={{ paddingRight: '0.3em', lineHeight: '1.35' }}>{word.text}</span>
                            ))}
                        </div>
                    </div>
                    <div className="mb-2"><span className="text-xs font-bold text-slate-400 uppercase pl-1">Translation</span></div>
                    <div className="bg-slate-100 rounded-xl border border-slate-200 p-5 mb-6 text-base md:text-lg leading-loose font-sans text-slate-700">
                        {JP_CHUNKS.map((chunk) => {
                            const isActive = (STEPS[currentStep].jpHighlightIds || []).includes(chunk.id);
                            return (
                                <span key={chunk.id} className={`transition-all duration-300 inline-block px-1 rounded-sm ${isActive ? 'bg-white shadow-sm font-bold text-slate-900' : 'opacity-50'}`} style={{ borderBottom: isActive ? `2px solid ${STEPS[currentStep].mainColor}` : '2px solid transparent' }}>{chunk.text}</span>
                            );
                        })}
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 sticky bottom-4 z-30">
                        <div className="md:col-span-1 flex flex-row md:flex-col gap-2 justify-between md:justify-start">
                            <div className="flex gap-2 w-full">
                                <button onClick={prevStep} disabled={currentStep === 0} className="flex-1 flex items-center justify-center gap-2 px-4 py-3 bg-white border border-slate-300 rounded-lg hover:bg-slate-50 disabled:opacity-50 shadow-sm"><ChevronLeft/> Prev</button>
                                <button onClick={nextStep} disabled={currentStep === STEPS.length - 1} className="flex-1 flex items-center justify-center gap-2 px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 shadow-md">Next <ChevronRight/></button>
                            </div>
                            <button onClick={() => setCurrentStep(0)} className="hidden md:flex items-center gap-2 text-slate-500 text-sm p-2 hover:bg-slate-100 rounded self-start"><RefreshCw/> Reset</button>
                        </div>
                        <div className="md:col-span-2 bg-slate-800 text-white p-5 rounded-lg shadow-xl border-l-4" style={{ borderLeftColor: STEPS[currentStep].mainColor || '#3b82f6' }}>
                            <h3 className="font-bold mb-1 text-blue-200">{STEPS[currentStep].title}</h3>
                            <p className="text-slate-300 text-sm md:text-base">{STEPS[currentStep].description}</p>
                        </div>
                    </div>
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<EnglishParser />);
    </script>
</body>
</html>